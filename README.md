There are several methdos for performing matrix-matrix multiplication on quantum computers. One method involves duplicating the ancilla qubits relying on block-encoding \cite{Gily_n_2019, takahira2021quantum}. The number of ancilla qubits and two-qubit swap gates required for matrix multiplication increases linearly with the number of matrix multiplications (see Appendix~\ref{app:C}). For example, computing $E^{p}$, the power $p$ of matrix $E$, using the duplicate ancilla qubits technique requires additional $O(p)$ ancilla qubits and $O(p)$ swap gates. Each swap gate is decomposed into 3 $CNOT$ gates. Consequently, the duplicate ancilla qubits technique is inefficient for multiplications of non-unitary matrices. Another method for multiplication of the non-unitary matrices is called compression gadget \cite{low2019}. The number of extra ancilla qubits needed for computing matrix multiplication increases logarithmically with the number of multiplications. For instance, $E^{p}$ can be computed with $O(log_{2}(p))$ ancilla qubits using the compression gadget. First, we explain the compression gadget in a lemma, and then we describe the quantum circuit for the compression gadget.  

Lemma 1(compression gadget for the matrix multiplications) \cite{Fang2023}. Suppose we are given unitaries $U_1, U_2, \ldots, U_L$, each of which is a $(\alpha'_l, m'_l, 0)$-block encoding of $A_l$. Then the $(\alpha_{\text{comp}}, m_{\text{comp}}, 0)$-block encoding of $A_L \cdots A_2 A_1$ is constructed, where
\begin{equation}
  \alpha_{\text{comp}} = \alpha'_1 \alpha'_2 \cdots \alpha'_L, \quad m_{\text{comp}} = \max_l (m'_l) + \lceil \log_2(L) \rceil + 1 \label{comp_qubit}  
\end{equation}
using one application of each $U_l$. In Eq. \ref{comp_qubit}, $m'_l$ is the number of qubits needed for block encoding of $A_l$. Fig.~\ref{fig:gadget} shows the quantum circuit for the compression gadget for multiplication of $A_{L}...A_{2}A_{1}$. The counter register in Fig.~\ref{fig:gadget} contains $log_{2}(L) + 1$ qubits. It is used to keep track of how many block encoding of $A_l$ have been applied successfully. 
The $ADD$ operation in Fig.~\ref{fig:gadget} is a unitary operation. It maps $ADD\ket{0} = \ket{1}$, $ADD\ket{1} = \ket{2}$,..., $ADD\ket{L-1} = \ket{L}$ and $ADD\ket{L} = \ket{0}$ and the $ADD^{\dagger}$ is the hermitian conjugate of $ADD$. It maps $ADD^{\dagger}\ket{0} = \ket{L}$, $ADD^{\dagger}\ket{L} = \ket{L-1}$, ..., $ADD^{\dagger}\ket{2} = \ket{1}$, and $ADD^{\dagger}\ket{1} = \ket{0}$.  

Let's consider that the initial state is $\ket{0}^{\otimes(c=log(L)+1)}\ket{0}^{\otimes(a=\frac{m'_l+1}{2})}\ket{0}^{\otimes(s=\frac{m'_l-1}{2})}$. First $ADD$ operator applies $L$ times on the counter register $c$ to map $\ket{0}^{\otimes c}$ to $\ket{L}^{\otimes c}$. The quantum state after step 1 is $\ket{L}^{\otimes c}\ket{0}^{\otimes a}\ket{0}^{\otimes s}$. Then the first unitary block encoding $U_1$ is applied on $\ket{L}^{\otimes c}\ket{0}^{\otimes a}\ket{0}^{\otimes s}$. This operation generate a superposition between $\ket{0}^{\otimes a}$ and $\ket{1}^{\otimes a}$. The quantum state is $\ket{L}^{\otimes c}(\ket{0}^{\otimes a}A_1\ket{0}^{\otimes s} + \ket{1}^{\otimes a}\ket{*}^{\otimes s})$. $\ket{*}$ is called a junk state. The next step is to utilize the ancilla register to change the information in the counter register. This is achieved by applying a controlled \( ADD^{\dagger} \) operation, conditioned on \( a \)-control qubits all in the state \( \ket{0}^{\otimes a} \). The quantum state after this operation (step 3) is $\ket{L-1}^{\otimes c}\ket{0}^{\otimes a}A_1\ket{0}^{\otimes s} + \ket{L}^{\otimes c}\ket{1}^{\otimes a}\ket{*}^{\otimes s}$. After step 3, another unitary block encoding $U_2$ is applied. The quantum state after applying $U_2$ operation is $\ket{L-1}^{\otimes c}(\ket{0}^{\otimes a}A_2A_1\ket{0}^{\otimes s} + \ket{1}^{\otimes a}\ket{*}^{\otimes s}) + \ket{L}^{\otimes c}(\ket{0}^{\otimes a}\ket{*}^{\otimes s}+\ket{1}^{\otimes a}\ket{*}^{\otimes s})$ (step 4). Then another controlled $ADD^{\dagger}$ by considering the control qubit $\ket{0}^{\otimes a}$ is applied and a new counter register $\ket{L-2}^{\otimes c}$ is generated. The new quantum state is $\ket{L-2}^{\otimes c}\ket{0}^{\otimes a}A_2A_1\ket{0}^{\otimes s} + \ket{L-1}^{\otimes c}\ket{1}^{\otimes a}\ket{*}^{\otimes s} + \ket{L-1}^{\otimes c}\ket{0}^{\otimes a}\ket{*}^{\otimes s}+\ket{L}\ket{1}^{\otimes a}\ket{*}^{\otimes s}$ (step 5). These steps must be repeated until all the unitary block encoding operations are applied and the counter register is brought back to its initial state $\ket{0}^{\otimes c}$. The quantum state before measuring the counter qubit and the ancilla qubits is $\ket{0}^{\otimes c}\ket{0}^{\otimes a}A_{L} ... A_2A_1\ket{0}^{\otimes s} + \sum_{j>0}\ket{j}\ket{*}\ket{*}$ (step 9). Measuring the counter qubits and the ancilla qubits on the basis $\ket{0}^{\otimes c}\ket{0}^{\otimes a}$ in combination with post-selection guarantee that the multiplication $A_{L}...A_{2}A_{1}$ is applied successfully (step 10). The code for matrix multiplication with the compressed gadget technique is available on GitHub.

\begin{figure}[tpb]
  \centering
\begin{quantikz}[slice all, remove end slices=1]
    \lstick[wires=1]{$counter$}& \gate[wires=1]{ADD^{L}} & \qw& \gate[wires=1]{ADD^{\dagger}} & \qw & \gate[wires=1]{ADD^{\dagger}} & \qw & \ \ldots\ & \qw & \gate[wires=1]{ADD^{\dagger}} & \meter{} & \qw \\ 
    \lstick[wires=1]{$ancilla$} & \qw & \gate[wires=2]{U_1} & \octrl{-1} & \gate[wires=2]{U_2} & \octrl{-1} & \qw & \ \ldots\ & \gate[wires=2]{U_{L}} & \octrl{-1} & \meter{} & \qw \\ 
      \lstick[wires=1]{$system$}& \qw& \qw & \qw &\qw& \qw & \qw & \ \ldots\ &  \qw & \qw & \qw & 
\end{quantikz}
\caption{Quantum Circuit for computation of matrix multiplication with compression gadget. $ADD$ is applied $L$ times on the counter register to maps $ADD^{L}\ket{0} = \ket{L}$ (step 1). At the next step, unitary block encoding $U_1$ is applied to the ancilla qubits and system qubits. This operation generates a superposition between $\ket{0}^{\otimes a}$ and $\ket{1}^{\otimes a}$ (step 2). The next step is to utilize the information in the ancilla register to change the information in the counter register. The controlled \( ADD^{\dagger} \) operation, conditioned on \( a \)-ancilla qubits all in the state \( \ket{0}^{\otimes a} \) is applied to change the information in the counter registers (step 3). Steps 2 and 3 are repeated until the quantum state of the counter register is brought back to $\ket{0}^{\otimes c}$. Finally, the counter register and ancilla registers are measured. The output after postselection is the matrix $A_{L}...A_{2}A_{1}$.} \label{fig:gadget}
\end{figure}
